% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xml_fragment.R
\name{.tags}
\alias{.tags}
\alias{.data}
\alias{xml_fragment}
\alias{xml_doc}
\title{simply create an XML fragment}
\usage{
.tags(..., .attr = NULL)

.data(df, row_tag = "obs")

xml_fragment(..., .attr = character())

xml_doc(..., .attr = character())
}
\arguments{
\item{...}{nest named elements and characters to include in the fragment (see example)}

\item{.attr}{attributes to be set on the root element}

\item{df}{data frame that will be stored as set of xml elements}

\item{row_tag}{the name of the row tag}
}
\value{
an \code{xml_fragment}, list object that can be converted to an \code{xml2::xml_document}
or \code{character} string
}
\description{
Create an xml fragment using readable R syntax, that can be used to create
an \code{xml2::xml_document} or as a building block for more complex XML documents.
}
\details{
An \code{xml_fragment} is built using
\itemize{
\item named \code{.tags} elements, each name is a tag name, and the value is the contents
of the tag. The contents can be a nested \code{.tags} object, a character string or a numeric value.
\item \code{.attr} attributes, which is set on current element, or on the \code{.tags} where
it is specified
\item unnamed elements, which are added as text nodes.
\item \code{.data} function that can be used to convert a data.frame to an xml fragment
}

An \code{xml_doc} is a special case of an \code{xml_fragment} that contains exactly one
root element, and errors when this is not the case.

A resulting \code{xml_fragment} object can be converted to an \code{xml2::xml_document} with
\code{\link[xml2:as_xml_document]{xml2::as_xml_document()}} or to a character string with \code{\link[=as.character]{as.character()}}. Both
methods are fast using a performant c++ implementation.
}
\examples{
doc <- xml_fragment(
  study = .tags(
    .attr = c(id="1"),
    person = .tags(
      .attr = c(id = "p1"),
      name = "John Doe",
      age = 30
    ),
    person = .tags(
      name = "Jane Doe",
      age = 25,
      address = .tags(street = "123 Main St", city = "Springfield"),
      "This is a text node"
    )
  )
)

print(doc)
if (require("xml2")){
  as_xml_document(doc)
}

# you can also create a function to generate xml elements,
# but remember that the enconsing element name must be used outside the
# function
person <- function(name, age, id){
  .tags(
    # xml attributes can be speficied with .attr
    .attr = c(id = id),
    name = name,
    age = age,
    address = .tags(street = "123 Main St", city = "Springfield")
  )
}

# xml_doc is a xml_fragment with the restriction of having one root element
doc2 <- xml_doc(
  study = .tags(
    # you need to specify "person" as the name for each element
    person = person("John Doe", 30, id = "p1"),
    person = person("Jane Doe", 25, id = "p2")
  )
)

print(doc2)
if (require("xml2")){
  as_xml_document(doc2)
}

# a fragment can have multiple root elements
fgmt <- xml_fragment(
  person = person("John Doe", 30, id = "p1"),
  person = person("Jane Doe", 25, id = "p2")
)

print(fgmt)

if (require("xml2")){
  # as_xml_document won't work because it expects a single root element,
  # so we retrieve a nodeset instead
  as_xml_nodeset(fgmt)
}

iris_xml <- xml_doc(
  fieldstudy = .tags(
    .attr = c(id = "iris", doi ="10.1111/j.1469-1809.1936.tb02137.x"),
    source = "Fisher, R. A. (1936) The use of multiple measurements in
taxonomic problems. Annals of Eugenics, 7, Part II, 179â€“188.",
    data = .data(iris, row_tag = "obs")
  )
)

print(iris_xml, max_characters = 300)

if (require("xml2")){
  as_xml_document(iris_xml)
}
}
